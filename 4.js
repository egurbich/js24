console.log("Завдання: 4 ==============================");

// Функція task4, яка буде використовувати проміси
function task4() {
  // Визначаємо перший проміс з іменем promise1
  const promise1 = new Promise((resolve, reject) => {
    // Використовуємо setTimeout, щоб симулювати асинхронну операцію
    setTimeout(() => {
      // Викликаємо resolve, яка змінює стан проміса на "виконано" і передає значення 'Проміс 1 виконано'
      resolve("Проміс 1 виконано");
    }, 1000); // 1 секунда затримки
  });

  // Визначаємо другий проміс з іменем promise2
  const promise2 = new Promise((resolve, reject) => {
    // Використовуємо setTimeout, щоб симулювати асинхронну операцію з затримкою 1 секунди
    setTimeout(() => {
      // Викликаємо resolve, яка змінює стан проміса на "виконано" і передає значення 'Проміс 2 виконано'
      resolve("Проміс 2 виконано");
    }, 1000); // 1 секунда затримки
  });

  // Promise.all приймає масив промісів і повертає новий проміс, який вирішується, коли всі вхідні проміси вирішені
  Promise.all([promise1, promise2])
    // Функція then викликається, коли проміс вирішений
    .then((results) => {
      // Результати всіх вхідних промісів передаються у функцію then у вигляді масиву
      // Виводимо в консоль масив результатів
      console.log(results);
    })
    // Функція catch викликається, коли будь-який з промісів відхилено
    .catch((error) => {
      // Повідомлення про помилку від першого відхиленого проміса передається у функцію catch
      // Виводимо в консоль помилку
      console.error("Помилка:", error);
    })
    // Функція finally викликається незалежно від того, чи вирішено проміс, чи відхилено
    .finally(() => {
      // Виводимо в консоль "Всі операції завершено"
      console.log("Всі операції завершено");
    });
}

// Викликаємо функцію task4
task4();
